diff -Nrup A/drivers/hid/Kconfig B/drivers/hid/Kconfig
--- A/drivers/hid/Kconfig	2018-10-20 16:19:27.231458801 +0200
+++ B/drivers/hid/Kconfig	2018-10-15 11:51:12.317478400 +0200
@@ -1028,6 +1028,13 @@ config HID_ALPS
 	Say Y here if you have a Alps touchpads over i2c-hid or usbhid
 	and want support for its special functionalities.
 
+config HID_IRMP
+	tristate "IRMP KBD HID device support"
+	depends on HID
+	---help---
+	Support for IRMP STM32 KBD HID remote control receivers.
+	Say Y here if you have a IRMP STM32 KBD.
+
 endmenu
 
 endif # HID
diff -Nrup A/drivers/hid/Makefile B/drivers/hid/Makefile
--- A/drivers/hid/Makefile	2017-12-14 09:53:15.000000000 +0100
+++ B/drivers/hid/Makefile	2018-10-15 11:24:18.139848500 +0200
@@ -114,6 +114,7 @@ obj-$(CONFIG_HID_WALTOP)	+= hid-waltop.o
 obj-$(CONFIG_HID_WIIMOTE)	+= hid-wiimote.o
 obj-$(CONFIG_HID_SENSOR_HUB)	+= hid-sensor-hub.o
 obj-$(CONFIG_HID_SENSOR_CUSTOM_SENSOR)	+= hid-sensor-custom.o
+obj-$(CONFIG_HID_IRMP)	+= hid-irmp.o
 
 obj-$(CONFIG_USB_HID)		+= usbhid/
 obj-$(CONFIG_USB_MOUSE)		+= usbhid/
diff -Nrup A/drivers/hid/hid-core.c B/drivers/hid/hid-core.c
--- A/drivers/hid/hid-core.c	2018-10-20 20:46:04.437594289 +0200
+++ B/drivers/hid/hid-core.c	2018-10-20 18:23:50.815154601 +0200
@@ -2076,6 +2076,9 @@ static const struct hid_device_id hid_ha
 #if IS_ENABLED(CONFIG_HID_ICADE)
 	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_ION, USB_DEVICE_ID_ICADE) },
 #endif
+#if IS_ENABLED(CONFIG_HID_IRMP)
+	{ HID_USB_DEVICE(USB_VENDOR_ID_IRMP, USB_DEVICE_ID_IRMP_STM32_KBD) },
+#endif
 #if IS_ENABLED(CONFIG_HID_ITE)
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ITE, USB_DEVICE_ID_ITE8595) },
 #endif
diff -Nrup A/drivers/hid/hid-ids.h B/drivers/hid/hid-ids.h
--- A/drivers/hid/hid-ids.h	2018-10-10 22:17:19.862057017 +0200
+++ B/drivers/hid/hid-ids.h	2018-10-16 23:23:38.618508200 +0200
@@ -1176,4 +1176,7 @@
 #define USB_VENDOR_ID_UGTIZER			0x2179
 #define USB_DEVICE_ID_UGTIZER_TABLET_GP0610	0x0053
 
+#define USB_VENDOR_ID_IRMP		0x1209
+#define USB_DEVICE_ID_IRMP_STM32_KBD	0x4444
+
 #endif
diff -Nrup A/drivers/hid/hid-irmp.c B/drivers/hid/hid-irmp.c
--- A/drivers/hid/hid-irmp.c	1970-01-01 01:00:00.000000000 +0100
+++ B/drivers/hid/hid-irmp.c	2018-10-20 20:05:01.250283536 +0200
@@ -0,0 +1,160 @@
+/*
+ *  HID driver for IRMP STM32 KBD remote
+ *
+ *  Copyright (c) 2018 Joerg Riechardt
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ */
+
+#include <linux/device.h>
+#include <linux/hid.h>
+#include <linux/module.h>
+
+#include "hid-ids.h"
+
+struct irmp_data {
+	struct hid_device *hdev;
+	struct input_dev *input;
+};
+
+static int irmp_raw_event(struct hid_device *hdev, struct hid_report *report,
+							u8 *raw_data, int size)
+{
+	struct irmp_data *hdata = hid_get_drvdata(hdev);
+	struct input_dev *input = hdata->input;
+	static unsigned int last_key = 0;
+	static unsigned int key;
+	static unsigned int key_mapped = 0;
+	key = ((raw_data[1]&0xFF) << 8) + (raw_data[3]&0xFF);
+	if(raw_data[3]&0xFF){
+		if (key == last_key) {
+			switch(raw_data[3]&0xFF) { // map usb_hid_keys.h <> input-event-codes.h max 194?!
+				case 0x1e: key_mapped = 2;	break; // KEY_1
+				case 0x1f: key_mapped = 3;	break; // KEY_2
+				case 0x20: key_mapped = 4;	break; // KEY_3
+				case 0x21: key_mapped = 5;	break; // KEY_4
+				case 0x22: key_mapped = 6;	break; // KEY_5
+				case 0x23: key_mapped = 7;	break; // KEY_6
+				case 0x24: key_mapped = 8;	break; // KEY_7
+				case 0x25: key_mapped = 9;	break; // KEY_8
+				case 0x26: key_mapped = 10;	break; // KEY_9
+				case 0x27: key_mapped = 11;	break; // KEY_0
+				case 0x10: key_mapped = 50;	break; // KEY_M
+				case 0x0c: key_mapped = 23;	break; // KEY_I
+				case 0x52: key_mapped = 103;	break; // KEY_UP
+				case 0x51: key_mapped = 108;	break; // KEY_DOWN
+				case 0x4f: key_mapped = 106;	break; // KEY_RIGHT
+				case 0x50: key_mapped = 105;	break; // KEY_LEFT
+				case 0x56: key_mapped = 74;	break; // KEY_KPMINUS
+				case 0x57: key_mapped = 78;	break; // KEY_KPPLUS
+				case 0x28: key_mapped = 28;	break; // KEY_ENTER
+				case 0x2a: key_mapped = 14;	break; // KEY_BACKSPACE
+				case 0x66: key_mapped = 116;	break; // KEY_POWER
+				case 0x41: key_mapped = 66;	break; // KEY_F8
+				case 0x44: key_mapped = 87;	break; // KEY_F11
+				case 0x45: key_mapped = 88;	break; // KEY_F12
+				case 0x68: key_mapped = 183;	break; // KEY_F13
+				case 0x69: key_mapped = 184;	break; // KEY_F14
+				case 0x6a: key_mapped = 185;	break; // KEY_F15
+				case 0x6b: key_mapped = 186;	break; // KEY_F16
+				case 0x6c: key_mapped = 187;	break; // KEY_F17
+				case 0x6d: key_mapped = 188;	break; // KEY_F18
+				case 0x6e: key_mapped = 189;	break; // KEY_F19
+				case 0x6f: key_mapped = 190;	break; // KEY_F20
+				case 0x70: key_mapped = 191;	break; // KEY_F21
+				case 0x71: key_mapped = 192;	break; // KEY_F22
+				case 0x67: key_mapped = 117;	break; // KEY_KPEQUAL
+				case 0x17: key_mapped = 20;  break; // KEY_T
+				case 0x08: key_mapped = 18;	 break; // KEY_E
+				default:
+					key_mapped = raw_data[3]&0xFF;
+			}
+			input_event(input, EV_KEY, key_mapped, 2);
+			input_sync(input);
+		} else {
+			last_key = key;
+		}
+	} else {
+		last_key = 0;
+	}
+
+	if(raw_data[1]&0xFF){
+		if (key == last_key) {
+			switch(raw_data[1]&0xFF) { // map usb_hid_keys.h <> input-event-codes.h max 194?!
+				case 0xe0: key_mapped = 29;	break; // KEY_LEFTCTRL
+				case 0xe4: key_mapped = 97;	break; // KEY_KEY_RIGHTCTRL
+				case 0xe1: key_mapped = 42;	break; // KEY_KEY_LEFTSHIFT
+				case 0xe5: key_mapped = 54;	break; // KEY_RIGHTSHIFT
+				case 0xe2: key_mapped = 56;	break; // KEY_LEFTALT
+				default:
+					key_mapped = raw_data[1]&0xFF;
+			}
+			input_event(input, EV_KEY, key_mapped, 2);
+			input_sync(input);
+		}
+	}
+
+	return 1;
+}
+
+static int irmp_input_configured(struct hid_device *hdev, struct hid_input *hidinput)
+{
+	struct irmp_data *irmp_data = hid_get_drvdata(hdev);
+	struct input_dev *input = hidinput->input;
+	irmp_data->input = input;
+	__clear_bit(EV_REP, input->evbit); // turn off repeat
+	hid_set_drvdata(hdev, irmp_data);
+	printk(KERN_ALERT "irmp configured\n");
+
+	return 0;
+}
+
+static int irmp_probe(struct hid_device *hdev, const struct hid_device_id *id)
+{
+	int ret;
+	struct irmp_data *irmp_data;
+
+	irmp_data = devm_kzalloc(&hdev->dev, sizeof(struct irmp_data), GFP_KERNEL);
+	if (irmp_data == NULL) {
+		hid_err(hdev, "can't alloc irmp descriptor\n");
+		return -ENOMEM;
+	}
+	irmp_data->hdev = hdev;
+	hid_set_drvdata(hdev, irmp_data);
+
+	ret = hid_parse(hdev);
+	if (ret) {
+		hid_err(hdev, "parse failed\n");
+		goto err_free;
+	}
+	ret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);
+	if (ret) {
+		hid_err(hdev, "hw start failed\n");
+		goto err_free;
+	}
+	return 0;
+err_free:
+	return ret;
+}
+
+static const struct hid_device_id irmp_devices[] = {
+	{ HID_USB_DEVICE(USB_VENDOR_ID_IRMP, USB_DEVICE_ID_IRMP_STM32_KBD) },
+	{ }
+};
+MODULE_DEVICE_TABLE(hid, irmp_devices);
+
+static struct hid_driver irmp_driver = {
+	.name = "irmp",
+	.id_table = irmp_devices,
+	.probe = irmp_probe,
+	.raw_event = irmp_raw_event,
+	.input_configured = irmp_input_configured,
+};
+module_hid_driver(irmp_driver);
+
+MODULE_LICENSE("GPL");
